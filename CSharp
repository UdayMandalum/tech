.NET 8 , C# 12 , VS 2022
C# is strong type language 
Var type : type conversion need to be explicit. For implicit conversion var type is used. type is inferred by C# at complite time. use of var is required in LINQ
switch vs if. switch complies to a lookup table, allowing the program to jump to the matching case, the expression is evaluated only once. 
 IF evaluates conditions sequencially. should be used when condition to evaluate is complex and case are few, say 3 or less. 
Strings, Array are reference types . Struct , Enumerations are value types
custom Types : Class, struct , Enumeration, Interface , Deligate
Enumeration : Giving name to a numerical value
Struct: Value type, similar to class like properties and methods. no garbage collection overheads. no unintended changes to original. 
     When you need to represent a small, simple data structure that holds a few fields (e.g., coordinates, points, or measurements).
     have lower memory overhead since they don’t require heap allocation or garbage collection.
Array
int [] arr = new int[5]; size once specified is fixed , channot be changed
int [] arr = new int[] {1,2,3,4,5};
Employee[] employees = new Employee[7];
CopyTo() , Sort(), Reverse(), Length

Collections : built in classes in dotnet, resizes dynamically
List<int> _list = new List<int> (); Add, Remove , Insert, Contains , Count, ToArray, clear . List are type safe . 
Nunit & xUnit : Arrage, Act & Assert

LINQ defines the extension method on IEnumerable<T> 
IEnumerable<string> seq = new[] {'www','eee', 'rrr'}; seq.First(); seq.Single(); Take(2), Skip(1)

IEnumerable<T> is the core interface for iterable collections in C# (e.g., lists, arrays)
You typically use IEnumerable<T> manually when you want to create a custom sequence of data that can be iterated over lazily (Lazy Evaluation), without storing the entire collection in memory.
This means that the elements of the collection are not necessarily loaded into memory or processed until they are actually requested during iteration. This can be beneficial for performance and memory usage, especially with large datasets

LINQ (Language Integrated Query) is a feature in C# that allows you to query data from various sources (e.g., collections, databases, XML, etc.)
using a consistent, SQL-like syntax directly within C#. 
Introduced in C# 3.0, LINQ provides a declarative way to filter, sort, group, and transform data, making code more readable and concise.
It works with any data source that implements IEnumerable<T> or IQueryable<T>.
Method syntax is more concise for simple queries; query syntax is better for complex queries with joins or grouping.
SelectMany() :In a nested data structure, allows combining parent and child data into a new structure

Generics in C# is a feature introduced in C# 2.0 that allows you to define classes, methods, interfaces, or other types with placeholder types (type parameters).
These placeholders are replaced with specific types when the generic type or method is used, enabling type-safe, reusable, and efficient code without sacrificing performance.
Generics are commonly used with collections (e.g., List<T>, Dictionary<TKey, TValue>), but they can also be applied to custom classes, structs, interfaces, and methods. Example Sorting
Type Safety: Generics ensure compile-time type checking, preventing runtime errors from incorrect type usage (unlike non-generic collections like ArrayList).
Reusability: Write a single generic class/method that works with any type, reducing code duplication.

Delegates : They are the type-safe mechanism in C# for passing methods as arguments (like a function pointer)
Also used associate event handlers with events by defining the method signature. Task.Run() schedules a delegate 

Lambda expressions are the modern, recommended standard for creating inline, anonymous functions
=>: This is the lambda operator. It means "goes to" or "is defined as."

Asynchronous Web Request : 
 GetAsync function,  async & await keywords are contextual keywords always used togather. 
private async void search() : async indicates that the method will contain async operations 
 
•	The async keyword enables the use of the await keyword inside the method, allowing you to asynchronously wait for operations (like I/O, HTTP requests, etc.).
•	The method returns a Task, which represents the ongoing operation. Callers can await this task to asynchronously wait for its completion.
•	If the method needs to return a value, you use async Task<T> instead, where T is the return type.

call the API method as task. This does not block the main thread.
await the API response when needed.
Always use async Task if method returns nothing. use sync void only for event handellers.

private async Task Search()
{
 using(var client = new HttpClient())
 {
  var response = await client.GetAsync(URL);
  var content = await response.content.ReadasStringAsync();
 }

}

Task Parallel Library (TPL) 
Parallel Programming : for CPU bound operations
Task is a way to respresent a asyn operation

Task.Run() schedules a delegate (e.g., a lambda expression or method) to run on a thread pool thread.
The thread pool is a managed set of reusable threads, optimized for short-lived tasks.optimizing for CPU usage and resource constraints.
Error Handling : Exceptions are captured in the Task and propagated via await.
Task.Run() uses the .NET thread pool, which reuses a small number of threads for multiple tasks, reducing overhead. 
The thread pool is managed by the runtime, optimizing for CPU usage and resource constraints.
Task.Run() supports cancellation via CancellationToken, allowing clean task termination. 
The cancellation token checks if the cancellation has been requested through the cancellation token source. The cancellation logic has to handel cancellation gracefully.

Use Task.Run() when 
You have CPU-bound work (heavy calculation)
You have legacy synchronous blocking code
You want to run something in background thread

Don't use, when you already have proper async API. Just await the method

Dispacher.Invoke() This this from async method to update the UI thread. 
Task.WhenAll(task collection) : Takes in a collections of Tasks and await till all of them are complete.
Task.WhenAny : returns the first task that got completed from a list of tasks.

PLINQ : Parallel implementation of LINQ . AsParallel() : add this as part of LINQ query before select. AsOrdered() , Take()
Specifying AsParallel will analyze the query to decided whether or not parallelisium should be used. 
