.NET 8 , C# 12 , VS 2022
C# is strong type language 
Var type : type conversion need to be explicit. For implicit conversion var type is used. type is inferred by C# at complite time. use of var is required in LINQ
switch vs if. switch complies to a lookup table, allowing the program to jump to the matching case, the expression is evaluated only once. 
 It evaluates conditions sequencially. should be used when condition to evaluate is complex and case are few, say 3 or less. 
Strings, Array are reference types . Struct , Enumerations are value types
custom Types : Class, struct , Enumeration, Interface , Deligate
Enumeration : Giving name to a numerical value
Struct: Value type, similar to class like properties and methods. no garbage collection overheads. no unintended changes to original. 
Array
int [] arr = new int[5]; size once specified is fixed , channot be changed
int [] arr = new int[] {1,2,3,4,5};
Employee[] employees = new Employee[7];
CopyTo() , Sort(), Reverse(), Length

Collections : built in classes in dotnet, resizes dynamically
List<int> _list = new List<int> (); Add, Remove , Insert, Contains , Count, ToArray, clear . List are type safe . 
Nunit & xUnit : Arrage, Act & Assert

LINQ defines the extension method on IEnumerable<T> 
IEnumerable<string> seq = new[] {'www','eee', 'rrr'}; seq.First(); seq.Single(); Take(2), Skip(1)

IEnumerable<T> is the core interface for iterable collections in C# (e.g., lists, arrays)
You typically use IEnumerable<T> manually when you want to create a custom sequence of data that can be iterated over lazily (Lazy Evaluation), without storing the entire collection in memory.
This means that the elements of the collection are not necessarily loaded into memory or processed until they are actually requested during iteration. This can be beneficial for performance and memory usage, especially with large datasets

Generics in C# is a feature introduced in C# 2.0 that allows you to define classes, methods, interfaces, or other types with placeholder types (type parameters).
These placeholders are replaced with specific types when the generic type or method is used, enabling type-safe, reusable, and efficient code without sacrificing performance.
Generics are commonly used with collections (e.g., List<T>, Dictionary<TKey, TValue>), but they can also be applied to custom classes, structs, interfaces, and methods. Example Sorting

Delegates : They are the type-safe mechanism in C# for passing methods as arguments (like a function pointer)
Also used associate event handlers with events by defining the method signature. Task.Run() schedules a delegate 

Lambda expressions are the modern, recommended standard for creating inline, anonymous functions
=>: This is the lambda operator. It means "goes to" or "is defined as."

Asynchronous Web Request : 
 GetAsync function,  async & await keywords are contextual keywords always used togather. 
private async void search() : async indicates that the method will contain async operations 
 
•	The async keyword enables the use of the await keyword inside the method, allowing you to asynchronously wait for operations (like I/O, HTTP requests, etc.).
•	The method returns a Task, which represents the ongoing operation. Callers can await this task to asynchronously wait for its completion.
•	If the method needs to return a value, you use async Task<T> instead, where T is the return type.

call the API method as task. This does not block the main thread.
await the API response when needed.


private async void Search()
{
 using(var client = new HttpClient())
 {
  var response = await client.GetAsync(URL);
  var content = await response.content.ReadasStringAsync();
 }

}

Task Parallel Library (TPL)
Parallel Programming : for CPU bound operations

Task.Run() schedules a delegate (e.g., a lambda expression or method) to run on a thread pool thread.
The thread pool is a managed set of reusable threads, optimized for short-lived tasks.optimizing for CPU usage and resource constraints.
