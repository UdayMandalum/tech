.NET 8 , C# 12 , VS 2022
C# is strong type language 
Var type : type conversion need to be explicit. For implicit conversion var type is used. type is inferred by C# at complite time. use of var is required in LINQ
switch vs if. switch complies to a lookup table, allowing the program to jump to the matching case, the expression is evaluated only once. 
 If evaluates conditions sequencially. should be used when condition to evaluate is complex and case are few, say 3 or less. 
Strings, Array are reference types . Struct , Enumerations are value types
custom Types : Class, struct , Enumeration, Interface , Deligate
Enumeration : Giving name to a numerical value
Struct: Value type, similar to class like properties and methods. no garbage collection overheads. no unintended changes to original. 
Array
int [] arr = new int[5]; size once specified is fixed , channot be changed
int [] arr = new int[] {1,2,3,4,5};
Employee[] employees = new Employee[7];
CopyTo() , Sort(), Reverse(), Length

Collections : built in classes in dotnet, resizes dynamically
List<int> _list = new List<int> (); Add, Remove , Insert, Contains , Count, ToArray, clear . List are type safe . 
Nunit & xUnit : Arrage, Act & Assert

LINQ defines the extension method on IEnumerable<T> 
IEnumerable<string> seq = new[] {'www','eee', 'rrr'}; seq.First(); seq.Single(); Take(2), Skip(1)

IEnumerable<T> is the core interface for iterable collections in C# (e.g., lists, arrays)
You typically use IEnumerable<T> manually when you want to create a custom sequence of data that can be iterated over lazily (Lazy Evaluation), without storing the entire collection in memory.
This means that the elements of the collection are not necessarily loaded into memory or processed until they are actually requested during iteration. This can be beneficial for performance and memory usage, especially with large datasets

Generics in C# is a feature introduced in C# 2.0 that allows you to define classes, methods, interfaces, or other types with placeholder types (type parameters).
These placeholders are replaced with specific types when the generic type or method is used, enabling type-safe, reusable, and efficient code without sacrificing performance.
Generics are commonly used with collections (e.g., List<T>, Dictionary<TKey, TValue>), but they can also be applied to custom classes, structs, interfaces, and methods. Example Sorting
